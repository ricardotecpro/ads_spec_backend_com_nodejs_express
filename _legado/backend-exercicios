# Back-End

### **Construindo e Testando a API do To-Do List**

**Objetivo:** Criar, passo a passo, o backend completo da nossa aplica√ß√£o, e aprender a testar cada funcionalidade de forma isolada usando uma ferramenta de cliente HTTP.

Exemplo 01
Exemplo 02
Exemplo 03

-----

### **Etapa 0: Configura√ß√£o Inicial do Projeto**

Vamos usar o **Spring Initializr** para criar a estrutura base do nosso projeto de forma r√°pida e segura.

1.  Acesse o site: [https://start.spring.io](https://start.spring.io)

2.  Preencha os campos da seguinte forma:

      * **Project:** Maven
      * **Language:** Java
      * **Spring Boot:** A vers√£o est√°vel mais recente (ex: 3.x.x).
      * **Project Metadata:**
          * **Group:** `br.com.curso`
          * **Artifact:** `listatarefas-api`
          * **Name:** `listatarefas-api`
          * **Description:** API para gerenciamento de tarefas
          * **Package name:** `br.com.curso.listatarefas.api`
      * **Packaging:** Jar
      * **Java:** 21 (ou a vers√£o que voc√™ instalou)

3.  No lado direito, em **Dependencies**, clique em "ADD DEPENDENCIES" e adicione as seguintes:

      * `Spring Web`: Essencial para criar aplica√ß√µes web e APIs REST.
      * `Spring Data JPA`: Facilita a comunica√ß√£o com o banco de dados.
      * `H2 Database`: Um banco de dados em mem√≥ria, perfeito para desenvolvimento e testes.
      * `Lombok`: Ajuda a reduzir a quantidade de c√≥digo repetitivo (como getters, setters e construtores).

4.  Clique no bot√£o **GENERATE**. Um arquivo `.zip` ser√° baixado.

5.  Descompacte o arquivo e abra a pasta gerada na sua IDE preferida (IntelliJ ou VS Code).

A estrutura de pastas inicial ser√° parecida com esta:

```
listatarefas-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ br/com/curso/listatarefas.api/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ listatarefas.apiApplication.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ application.properties
‚îÇ   ‚îî‚îÄ‚îÄ test/
‚îî‚îÄ‚îÄ pom.xml
```

-----

### **Etapa 1: Criando o Model (A Entidade `Tarefa`)**

O Model representa os dados da nossa aplica√ß√£o. Vamos criar a classe `Tarefa`.

1.  Dentro do pacote `br.com.curso.listatarefas.api`, crie um novo pacote chamado `tarefa`.
2.  Dentro de `br.com.curso.listatarefas.api.tarefa`, crie um novo arquivo Java chamado `Tarefa.java`.

**C√≥digo para `Tarefa.java`:**

```java
package br.com.curso.listatarefas.api.tarefa;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

/**
 * @Entity: Marca esta classe como uma entidade JPA (uma tabela no banco de dados).
 * @Table(name = "tb_tarefas"): Especifica o nome da tabela no banco.
 * @Data (Lombok): Gera automaticamente getters, setters, toString, equals e hashCode.
 */
@Data
@Entity
@Table(name = "tb_tarefas")
public class Tarefa {

    /**
     * @Id: Marca este campo como a chave prim√°ria da tabela.
     * @GeneratedValue: Configura a estrat√©gia de gera√ß√£o da chave prim√°ria.
     * IDENTITY significa que o pr√≥prio banco de dados ir√° gerar e gerenciar o valor.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String descricao;
    private boolean concluida;
}
```

-----

### **Etapa 2: Criando o Repository (A Camada de Acesso a Dados)**

O Repository √© uma interface que nos d√° os m√©todos para interagir com o banco de dados (salvar, buscar, deletar, etc.) sem precisarmos escrever SQL.

1.  No mesmo pacote `br.com.curso.listatarefas.api.tarefa`, crie uma nova **interface** Java chamada `TarefaRepository.java`.

**C√≥digo para `TarefaRepository.java`:**

```java
package br.com.curso.listatarefas.api.tarefa;

import org.springframework.data.jpa.repository.JpaRepository;

/**
 * JpaRepository √© uma interface do Spring Data JPA que j√° vem com m√©todos CRUD prontos.
 * Precisamos apenas dizer qual a Entidade que ele ir√° gerenciar (Tarefa) e qual o tipo da chave prim√°ria (Long).
 */
public interface TarefaRepository extends JpaRepository<Tarefa, Long> {
}

```

√â s√≥ isso\! O Spring Data JPA implementar√° essa interface em tempo de execu√ß√£o para n√≥s.

-----

### **Etapa 3: Criando a Camada de Servi√ßo (Regras de Neg√≥cio)**

√â uma boa pr√°tica ter uma camada de Servi√ßo para conter a l√≥gica de neg√≥cio, mantendo o Controller "limpo".

1.  No pacote `br.com.curso.listatarefas.api.tarefa`, crie uma nova classe Java chamada `TarefaService.java`.

**C√≥digo para `TarefaService.java`:**

```java
package br.com.curso.listatarefas.api.tarefa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * @Service: Marca a classe como um componente de servi√ßo do Spring,
 * onde colocamos a l√≥gica de neg√≥cio.
 */
@Service
public class TarefaService {

    // @Autowired: O Spring ir√° injetar uma inst√¢ncia de TarefaRepository aqui.
    @Autowired
    private TarefaRepository tarefaRepository;

    public Tarefa criar(Tarefa tarefa) {
        // Poder√≠amos ter valida√ß√µes aqui antes de salvar
        return tarefaRepository.save(tarefa);
    }

    public List<Tarefa> listarTodas() {
        return tarefaRepository.findAll();
    }

    public Optional<Tarefa> buscarPorId(Long id) {
        return tarefaRepository.findById(id);
    }

    public Tarefa atualizar(Long id, Tarefa tarefaAtualizada) {
        // Verifica se a tarefa existe antes de tentar atualizar
        return tarefaRepository.findById(id)
            .map(tarefaExistente -> {
                tarefaExistente.setDescricao(tarefaAtualizada.getDescricao());
                tarefaExistente.setConcluida(tarefaAtualizada.isConcluida());
                return tarefaRepository.save(tarefaExistente);
            }).orElseThrow(() -> new RuntimeException("Tarefa n√£o encontrada com o id: " + id));
    }

    public void deletar(Long id) {
        // Verifica se a tarefa existe antes de deletar para evitar erros
        if (!tarefaRepository.existsById(id)) {
            throw new RuntimeException("Tarefa n√£o encontrada com o id: " + id);
        }
        tarefaRepository.deleteById(id);
    }
}
```

-----

### **Etapa 4: Criando o Controller (A API REST)**

O Controller √© a porta de entrada da nossa API. Ele recebe as requisi√ß√µes HTTP e as direciona para a camada de Servi√ßo.

1.  No pacote `br.com.curso.listatarefas.api.tarefa`, crie uma nova classe Java chamada `TarefaController.java`.

**C√≥digo para `TarefaController.java`:**

```java
package br.com.curso.listatarefas.api.tarefa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * @RestController: Combina @Controller e @ResponseBody, simplificando a cria√ß√£o de APIs REST.
 * @RequestMapping: Define o caminho base para todos os endpoints neste controller.
 * @CrossOrigin: Permite que requisi√ß√µes de outras origens (como nosso frontend Angular) sejam aceitas.
 */
@RestController
@RequestMapping("/api/tarefas")
@CrossOrigin(origins = "*")
public class TarefaController {

    @Autowired
    private TarefaService tarefaService;

    // CREATE
    @PostMapping
    public Tarefa criarTarefa(@RequestBody Tarefa tarefa) {
        return tarefaService.criar(tarefa);
    }

    // READ - Listar Todas
    @GetMapping
    public List<Tarefa> listarTarefas() {
        return tarefaService.listarTodas();
    }

    // READ - Buscar por ID
    @GetMapping("/{id}")
    public ResponseEntity<Tarefa> buscarTarefaPorId(@PathVariable Long id) {
        return tarefaService.buscarPorId(id)
                .map(ResponseEntity::ok) // Se encontrar, retorna 200 OK com a tarefa
                .orElse(ResponseEntity.notFound().build()); // Se n√£o, retorna 404 Not Found
    }

    // UPDATE
    @PutMapping("/{id}")
    public ResponseEntity<Tarefa> atualizarTarefa(@PathVariable Long id, @RequestBody Tarefa tarefa) {
        try {
            Tarefa atualizada = tarefaService.atualizar(id, tarefa);
            return ResponseEntity.ok(atualizada);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }

    // DELETE
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarTarefa(@PathVariable Long id) {
        try {
            tarefaService.deletar(id);
            return ResponseEntity.noContent().build(); // Retorna 204 No Content, sucesso sem corpo
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
}
```

**Neste ponto, a nossa API est√° completa\!** Vamos execut√°-la.

1.  Encontre o arquivo `listatarefas.apiApplication.java`.
2.  Clique com o bot√£o direito sobre ele e selecione "Run 'listatarefas.apiApplication'".
3.  O console da sua IDE mostrar√° o log de inicializa√ß√£o do Spring Boot. Se tudo deu certo, voc√™ ver√° uma mensagem como `Started listatarefas.apiApplication in X.XXX seconds`.

-----

### **Etapa 5: Testando a API com Postman, Insomnia, YARC! **

Agora vamos agir como se f√¥ssemos o frontend, enviando requisi√ß√µes para a nossa API em execu√ß√£o.

#### **Teste 1: Criar uma Tarefa (CREATE)**

  * **M√©todo HTTP:** `POST`
  * **URL:** `http://localhost:8080/api/tarefas`
  * **Body:** V√° para a aba "Body", selecione a op√ß√£o `raw` e o formato `JSON`.
  * **Conte√∫do do Body:**
    ```json
    {
        "descricao": "Aprender a testar APIs REST",
        "concluida": false
    }
    ```
  * **A√ß√£o:** Clique em "Send".
  * **Resultado Esperado:** Voc√™ deve receber um status `200 OK` e, no corpo da resposta, o JSON da tarefa que voc√™ acabou de criar, agora com um `id` (provavelmente `1`).

#### **Teste 2: Listar Todas as Tarefas (READ)**

  * **M√©todo HTTP:** `GET`
  * **URL:** `http://localhost:8080/api/tarefas`
  * **A√ß√£o:** Clique em "Send".
  * **Resultado Esperado:** Status `200 OK` e um array JSON no corpo da resposta contendo a tarefa criada no passo anterior.

#### **Teste 3: Atualizar uma Tarefa (UPDATE)**

  * **M√©todo HTTP:** `PUT`
  * **URL:** `http://localhost:8080/api/tarefas/1` (use o `id` da tarefa que voc√™ criou)
  * **Body:** Novamente, `raw` e `JSON`.
  * **Conte√∫do do Body:**
    ```json
    {
        "descricao": "API testada e atualizada com sucesso!",
        "concluida": true
    }
    ```
  * **A√ß√£o:** Clique em "Send".
  * **Resultado Esperado:** Status `200 OK` e o JSON da tarefa com os dados atualizados.

#### **Teste 4: Deletar uma Tarefa (DELETE)**

  * **M√©todo HTTP:** `DELETE`
  * **URL:** `http://localhost:8080/api/tarefas/1`
  * **A√ß√£o:** Clique em "Send".
  * **Resultado Esperado:** Status `204 No Content`. A resposta n√£o ter√° corpo, o que √© normal para esta opera√ß√£o.

#### **Verifica√ß√£o Final**

Repita o **Teste 2 (Listar Todas)**. O resultado esperado agora √© um status `200 OK` com um array JSON vazio `[]`, confirmando que a exclus√£o funcionou.

**Parab√©ns\!** Seus alunos agora t√™m um backend robusto e funcional, e sabem como verificar cada parte dele. Eles est√£o prontos para construir os clientes web e desktop.


### **Etapa 6: Acessando o Console do Banco de Dados H2 em seu Projeto Spring Boot

Para desenvolvedores que utilizam o Spring Boot, o banco de dados em mem√≥ria H2 √© uma ferramenta extremamente √∫til para desenvolvimento e testes. Ele permite a cria√ß√£o e manipula√ß√£o de um banco de dados relacional que existe apenas durante a execu√ß√£o da aplica√ß√£o, sem a necessidade de configurar um servidor de banco de dados externo. Uma de suas grandes vantagens √© o console web, que oferece uma interface gr√°fica para interagir diretamente com o banco de dados.

Acessar este console, no entanto, exige algumas configura√ß√µes espec√≠ficas no seu projeto Spring Boot, especialmente se voc√™ estiver utilizando o Spring Security. A seguir, apresentamos um guia passo a passo para habilitar e acessar o console do H2.

### 1\. Adicionando as Depend√™ncias Necess√°rias

O primeiro passo √© garantir que as depend√™ncias do Spring Data JPA e do H2 estejam presentes no seu arquivo `pom.xml` (caso utilize Maven) ou `build.gradle` (caso utilize Gradle).

**Maven (`pom.xml`):**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

**Gradle (`build.gradle`):**

```groovy
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'com.h2database:h2'
```

A depend√™ncia `spring-boot-starter-data-jpa` prov√™ a infraestrutura para persist√™ncia de dados, enquanto a `h2` inclui o driver do banco de dados em mem√≥ria. A anota√ß√£o `<scope>runtime</scope>` (ou `runtimeOnly` no Gradle) indica que essa depend√™ncia √© necess√°ria apenas em tempo de execu√ß√£o.

### 2\. Configurando o `application.properties`

Em seguida, voc√™ precisa configurar sua aplica√ß√£o para utilizar o banco de dados H2 e habilitar o seu console. Adicione as seguintes propriedades ao seu arquivo `src/main/resources/application.properties`:

```properties
# Configura√ß√µes do H2
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# Configura√ß√µes do Datasource
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
```

**Entendendo as propriedades:**

  * `spring.h2.console.enabled=true`: Habilita o console web do H2.
  * `spring.h2.console.path=/h2-console`: Define o caminho (endpoint) para acessar o console. Voc√™ pode alter√°-lo se desejar.
  * `spring.datasource.url=jdbc:h2:mem:testdb`: Configura a URL de conex√£o do JDBC. `mem:testdb` indica que o banco de dados se chamar√° `testdb` e ser√° armazenado em mem√≥ria.
  * `spring.datasource.driverClassName`, `spring.datasource.username`, `spring.datasource.password`: Definem o driver, o nome de usu√°rio e a senha para a conex√£o com o banco de dados. O H2, por padr√£o, utiliza "sa" como usu√°rio e uma senha em branco.
  * `spring.jpa.database-platform`: Informa ao Hibernate qual dialeto SQL utilizar.

Se voc√™ prefere o formato YAML (`application.yml`), a configura√ß√£o equivalente √©:

```yaml
spring:
  h2:
    console:
      enabled: true
      path: /h2-console
  datasource:
    url: jdbc:h2:mem:testdb
    driverClassName: org.h2.Driver
    username: sa
    password:
    jpa:
      database-platform: org.hibernate.dialect.H2Dialect
```

### 3\. Configurando o Spring Security

Se o seu projeto utiliza o Spring Security, simplesmente habilitar o console do H2 n√£o ser√° suficiente. Por padr√£o, o Spring Security bloqueia o acesso a todos os endpoints, incluindo o do console do H2. Al√©m disso, o console do H2 utiliza frames HTML, que tamb√©m s√£o bloqueados por padr√£o como uma medida de seguran√ßa contra ataques de *clickjacking*.

Para permitir o acesso, voc√™ precisar√° criar ou modificar sua classe de configura√ß√£o do Spring Security. Em vers√µes recentes do Spring Boot (3.x e superiores), a configura√ß√£o √© feita atrav√©s de um `Bean` do tipo `SecurityFilterChain`.

Crie uma classe de configura√ß√£o de seguran√ßa (por exemplo, `SecurityConfig.java`):

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import static org.springframework.boot.autoconfigure.security.servlet.PathRequest.toH2Console;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(toH2Console()).permitAll()
                .anyRequest().authenticated()
            )
            .csrf(csrf -> csrf
                .ignoringRequestMatchers(toH2Console())
            )
            .headers(headers -> headers
                .frameOptions(frameOptions -> frameOptions.sameOrigin())
            );

        return http.build();
    }
}
```

**An√°lise da configura√ß√£o de seguran√ßa:**

  * `.requestMatchers(toH2Console()).permitAll()`: Permite todas as requisi√ß√µes para o caminho do console do H2. O m√©todo `toH2Console()` da classe `PathRequest` √© uma forma conveniente de referenciar o caminho configurado em `spring.h2.console.path`.
  * `.csrf(csrf -> csrf.ignoringRequestMatchers(toH2Console()))`: Desabilita a prote√ß√£o contra Cross-Site Request Forgery (CSRF) para o console do H2. Isso √© necess√°rio porque o console n√£o envia tokens CSRF.
  * `.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()))`: Permite que p√°ginas da mesma origem sejam exibidas em frames. Isso √© crucial para que o console do H2, que utiliza frames, seja renderizado corretamente no navegador.

### 4\. Acessando o Console

Com as configura√ß√µes acima aplicadas, inicie sua aplica√ß√£o Spring Boot. Em seguida, abra seu navegador e acesse a URL:

**Acesse o site:  [http://localhost:8080/h2-console](http://localhost:8080/h2-console)**

(Lembre-se de substituir `8080` pela porta em que sua aplica√ß√£o est√° rodando, se for diferente).

Na tela de login do console do H2, certifique-se de que o campo "JDBC URL" corresponde exatamente ao valor que voc√™ definiu em `spring.datasource.url` (`jdbc:h2:mem:testdb`). Preencha o nome de usu√°rio ("sa") e a senha (deixe em branco) e clique em "Connect".

## Caso Tenha uma mensagem de erro
Database "C:/Users/[SEU_USUARIO]/test" not found, either pre-create it or allow remote database creation (not recommended in secure environments) [90149-232] 90149/90149 (Help)

**üìåÔ∏è SOLU√á√ÉO RECOMENDADA

```
jdbc:h2:~/test

mudar para

jdbc:h2:mem:testdb

```

Esse erro aparece porque sua configura√ß√£o est√° apontando para um banco **H2 no disco** (`jdbc:h2:file:` impl√≠cito) que n√£o existe, mas no seu `application.properties` voc√™ disse que quer usar **em mem√≥ria** (`jdbc:h2:mem:testdb`).

Se o Spring Boot est√° reclamando de `C:/Users/[SEU_USUARIO]/test`, significa que em algum ponto do seu projeto (ou depend√™ncia) a URL do H2 foi alterada para `jdbc:h2:file:C:/Users/[SEU_USUARIO]/test`.

Voc√™ tem tr√™s caminhos para corrigir:

---

**1Ô∏è‚É£ Usar banco em mem√≥ria (n√£o persiste entre execu√ß√µes)**
Isso funciona bem para testes. Basta manter assim no `application.properties` e garantir que n√£o tem outro lugar sobrescrevendo:

```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```

> Dica: verifique se **n√£o existe** outro arquivo `application.properties` ou `application.yml` com configura√ß√£o diferente.

---

**2Ô∏è‚É£ Usar banco no disco e criar automaticamente**
Se voc√™ quer que o H2 seja salvo no PC e n√£o em mem√≥ria, configure assim:

```properties
spring.datasource.url=jdbc:h2:file:~/test;AUTO_SERVER=TRUE;AUTO_CREATE=TRUE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```

Isso cria o arquivo `~/test.mv.db` (na pasta do usu√°rio) na primeira execu√ß√£o.

---

**3Ô∏è‚É£ Usar banco no disco em caminho espec√≠fico**
Se quiser manter em `C:/Users/[SEU_USUARIO]/test`, pode criar o banco antes ou permitir cria√ß√£o autom√°tica:

```properties
spring.datasource.url=jdbc:h2:file:C:/Users/[SEU_USUARIO]/test;AUTO_SERVER=TRUE;AUTO_CREATE=TRUE
```

> ‚ö† `AUTO_CREATE=TRUE` √© √∫til para desenvolvimento, mas n√£o √© recomendado em produ√ß√£o.

---

Pronto\! Voc√™ agora tem acesso total √† interface do banco de dados H2, onde pode visualizar tabelas, executar queries SQL e gerenciar seus dados de desenvolvimento de forma pr√°tica e eficiente.

---

### [ricardotecpro.github.io](https://ricardotecpro.github.io/)
